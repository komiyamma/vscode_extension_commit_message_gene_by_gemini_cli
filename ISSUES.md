# 現在確認されている問題点

このプロジェクトには、アーキテクチャと実装に起因するいくつかの問題が存在します。

## 1. クロスプラットフォーム非対応

**問題点:**
現在の実装は、Windowsの実行ファイルである `gemini_proxy.exe` を介して `gemini` CLI を呼び出しています。
このため、macOSやLinuxといった他のオペレーティングシステムでは、この拡張機能は一切動作しません。

**改善案:**
C#で書かれたヘルパープロセスを廃止し、Node.js標準の `child_process` モジュールを使用して、`gemini` コマンドを直接呼び出すように変更します。これにより、プラットフォーム間の互換性が確保されます。

## 2. 設定の柔軟性の欠如

**問題点:**
使用するGeminiのモデル名 (`gemini-2.5-flash`) と、コミットメッセージ生成のためのプロンプトが、C#のソースコード内にハードコーディングされています。
ユーザーがモデルを変更したり、プロンプトを自身のユースケースに合わせて調整したりすることができません。

**改善案:**
VS Codeの `settings.json` を通じて、以下の項目を設定可能にします。
- `gemini.model`: 使用するモデル名 (例: `gemini-2.5-pro`)
- `gemini.prompt`: カスタムプロンプトのテンプレート

## 3. 複雑すぎるアーキテクチャ

**問題点:**
TypeScript (Node.js) から直接 `gemini` CLI を呼び出すことが可能であるにもかかわらず、C#で書かれた中間的なヘルパープロセス (`gemini_proxy.exe`) を利用しています。
これは不必要にアーキテクチャを複雑化させており、メンテナンスコストの増大や、デバッグの困難化を招いています。

**改善案:**
`gemini_proxy` プロジェクトを完全に廃止し、すべてのロジックを `src/extension.ts` 内に集約します。

## 4. 不安定な依存関係の解決

**問題点:**
ヘルパープロセスは、`npm config get prefix` の実行結果や `%APPDATA%\npm` といった特定のパスを頼りに `gemini.cmd` を探索します。
この方法は、Node.jsのバージョン管理ツール (nvmなど) を使用している環境や、npmのグローバルパスが異なる環境では失敗する可能性が高く、非常に不安定です。

**改善案:**
`gemini` CLIへのパスをVS Codeの設定項目としてユーザーが指定できるようにするか、システムの環境変数 `PATH` から探索する、より堅牢な方法に変更します。

## 5. 脆いプロセス間通信

**問題点:**
拡張機能本体とヘルパープロセス間の通信は、`■★■★■` のような特殊なマーカー文字列に依存して行われています。
この方法は、`gemini` CLIの出力形式が将来変更された場合に容易に破綻する可能性があり、非常に脆い（brittle）実装です。

**改善案:**
可能であれば、`gemini` CLIにJSON形式で出力させるオプションを利用し、より構造化されたデータ交換を行います。それができない場合でも、より頑健な出力解析ロジックを実装する必要があります。
